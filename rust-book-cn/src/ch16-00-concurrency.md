# 无畏并发

安全且高效地处理并发编程是 Rust 的另一个主要目标。**并发编程**（concurrent programming），即程序的不同部分独立执行；以及**并行编程**（parallel programming），即程序的不同部分同时执行——随着越来越多的计算机利用其多核处理器，这两者变得日益重要。从历史上看，在这些场景下编程一直是困难且容易出错的。Rust 希望改变这一现状。

最初，Rust 团队认为确保内存安全和防止并发问题是两个需要用不同方法解决的独立挑战。随着时间的推移，团队发现所有权和类型系统是一套强大的工具，能够帮助管理内存安全**和**并发问题！通过利用所有权和类型检查，许多并发错误在 Rust 中是编译时错误而非运行时错误。因此，你不必花费大量时间去重现运行时并发 bug 出现的确切条件，不正确的代码会直接拒绝编译并给出解释问题的错误信息。这样，你可以在编写代码时就修复问题，而不是在代码部署到生产环境之后才发现。我们将 Rust 的这一特性称为**无畏并发**（fearless concurrency）。无畏并发让你能够编写没有隐蔽 bug 的代码，并且在重构时不会引入新的 bug。

> 注意：为了简洁起见，我们将许多问题统称为**并发**问题，而不是更精确地说**并发和/或并行**。在本章中，当我们使用**并发**一词时，请在心中将其替换为**并发和/或并行**。在下一章中，由于区分这两者更为重要，我们会更加精确地表述。

许多语言在处理并发问题时提供的解决方案是教条式的。例如，Erlang 拥有优雅的消息传递并发功能，但在线程之间共享状态方面只有晦涩的方式。只支持可能解决方案的一个子集，对于高级语言来说是一种合理的策略，因为高级语言通过放弃一些控制权来换取抽象所带来的好处。然而，低级语言则被期望在任何给定场景下都能提供性能最优的解决方案，并且对硬件的抽象更少。因此，Rust 提供了多种工具，让你能够以适合自身场景和需求的方式来建模问题。

以下是本章将要涵盖的主题：

- 如何创建线程来同时运行多段代码
- **消息传递**（message-passing）并发，其中通道（channel）在线程之间发送消息
- **共享状态**（shared-state）并发，其中多个线程可以访问同一份数据
- `Sync` 和 `Send` trait，它们将 Rust 的并发保证扩展到用户自定义类型以及标准库提供的类型