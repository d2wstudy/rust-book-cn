## 面向对象语言的特征

关于一门语言必须具备哪些特性才能被视为面向对象的，编程社区并没有达成共识。Rust 受到了许多编程范式的影响，其中包括面向对象编程（OOP）；例如，我们在第 13 章探讨了来自函数式编程的特性。可以说，面向对象语言通常具有某些共同特征——即对象、封装和继承。让我们逐一看看这些特征的含义，以及 Rust 是否支持它们。

### 对象包含数据和行为

Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著的《设计模式：可复用面向对象软件的基础》（Addison-Wesley，1994）一书，通常被称为"四人帮"（_The Gang of Four_）之书，是一本面向对象设计模式的目录。书中对面向对象编程的定义如下：

> 面向对象的程序由对象组成。**对象**将数据和操作数据的过程打包在一起。这些过程通常被称为**方法**或**操作**。

按照这个定义，Rust 是面向对象的：结构体和枚举拥有数据，而 `impl` 块为结构体和枚举提供了方法。尽管带有方法的结构体和枚举并不被*称为*对象，但根据"四人帮"对对象的定义，它们提供了相同的功能。

### 封装隐藏了实现细节

面向对象编程中另一个常见的概念是**封装**（_encapsulation_），它意味着对象的实现细节对使用该对象的代码不可访问。因此，与对象交互的唯一方式是通过其公共 API；使用对象的代码不应该能够深入对象内部直接修改数据或行为。这使得程序员可以修改和重构对象的内部实现，而无需改动使用该对象的代码。

我们在第 7 章讨论了如何控制封装：可以使用 `pub` 关键字来决定代码中哪些模块、类型、函数和方法应该是公开的，而默认情况下其他所有内容都是私有的。例如，我们可以定义一个 `AveragedCollection` 结构体，其中包含一个存储 `i32` 值的 vector 字段。该结构体还可以有一个字段来存储 vector 中值的平均值，这样就不必在每次需要时都重新计算平均值。换句话说，`AveragedCollection` 会为我们缓存计算好的平均值。示例 18-1 展示了 `AveragedCollection` 结构体的定义。

<Listing number="18-1" file-name="src/lib.rs" caption="一个 `AveragedCollection` 结构体，维护一个整数列表以及集合中元素的平均值">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-01/src/lib.rs}}
```

</Listing>

该结构体被标记为 `pub`，这样其他代码就可以使用它，但结构体内部的字段仍然是私有的。这一点在此场景中很重要，因为我们希望确保每当列表中添加或移除一个值时，平均值也会随之更新。我们通过在结构体上实现 `add`、`remove` 和 `average` 方法来做到这一点，如示例 18-2 所示。

<Listing number="18-2" file-name="src/lib.rs" caption="在 `AveragedCollection` 上实现公共方法 `add`、`remove` 和 `average`">

```rust,noplayground
{{#rustdoc_include ../listings/ch18-oop/listing-18-02/src/lib.rs:here}}
```

</Listing>

公共方法 `add`、`remove` 和 `average` 是访问或修改 `AveragedCollection` 实例中数据的唯一途径。当使用 `add` 方法向 `list` 添加元素或使用 `remove` 方法移除元素时，每个方法的实现都会调用私有的 `update_average` 方法来同步更新 `average` 字段。

我们将 `list` 和 `average` 字段保持为私有，这样外部代码就无法直接向 `list` 字段添加或移除元素；否则，当 `list` 发生变化时，`average` 字段可能会与之不同步。`average` 方法返回 `average` 字段中的值，允许外部代码读取平均值但不能修改它。

由于我们封装了 `AveragedCollection` 结构体的实现细节，将来可以轻松地更改某些方面，比如数据结构。例如，我们可以将 `list` 字段从 `Vec<i32>` 改为 `HashSet<i32>`。只要 `add`、`remove` 和 `average` 这些公共方法的签名保持不变，使用 `AveragedCollection` 的代码就无需修改。如果我们将 `list` 设为公开的，情况就不一定如此了：`HashSet<i32>` 和 `Vec<i32>` 有不同的添加和移除元素的方法，因此如果外部代码直接修改 `list`，就很可能需要做出相应的改动。

如果封装是一门语言被视为面向对象的必要条件，那么 Rust 满足这一要求。对代码的不同部分选择使用或不使用 `pub`，就能实现对实现细节的封装。

### 继承作为类型系统与代码共享机制

**继承**（_inheritance_）是一种机制，通过它一个对象可以继承另一个对象定义中的元素，从而获得父对象的数据和行为，而无需重新定义它们。

如果一门语言必须具有继承才能被视为面向对象的，那么 Rust 就不是这样的语言。在 Rust 中，没有办法在不使用宏的情况下定义一个继承父结构体字段和方法实现的结构体。

然而，如果你习惯了在编程工具箱中使用继承，你可以在 Rust 中使用其他方案，具体取决于你最初使用继承的原因。

选择继承主要有两个原因。第一个是代码复用：你可以为某个类型实现特定的行为，而继承使你能够为另一个类型复用该实现。在 Rust 中，你可以通过默认 trait 方法实现来有限度地做到这一点，正如我们在示例 10-14 中为 `Summary` trait 添加 `summarize` 方法的默认实现时所看到的那样。任何实现了 `Summary` trait 的类型都可以直接使用 `summarize` 方法，而无需编写额外的代码。这类似于父类拥有一个方法的实现，而继承的子类也拥有该方法的实现。我们还可以在实现 `Summary` trait 时覆盖 `summarize` 方法的默认实现，这类似于子类覆盖从父类继承的方法实现。

使用继承的另一个原因与类型系统有关：使子类型能够在与父类型相同的位置使用。这也被称为**多态**（_polymorphism_），意味着如果多个对象共享某些特征，它们可以在运行时相互替换。

> ### 多态
>
> 对许多人来说，多态就是继承的同义词。但它实际上是一个更通用的概念，指的是能够处理多种类型数据的代码。对于继承而言，这些类型通常是子类。
>
> Rust 则使用泛型（generics）来抽象不同的可能类型，并使用 trait 约束来限定这些类型必须提供的功能。这有时被称为**有界参数多态**（_bounded parametric polymorphism_）。

Rust 选择了一组不同的权衡方案，没有提供继承。继承往往有共享过多代码的风险。子类不应该总是共享父类的所有特征，但使用继承时就会如此。这会使程序的设计变得不够灵活。它还引入了在子类上调用不合理或会导致错误的方法的可能性，因为这些方法并不适用于该子类。此外，有些语言只允许**单继承**（即一个子类只能继承自一个类），这进一步限制了程序设计的灵活性。

出于这些原因，Rust 采用了不同的方式，使用 trait 对象而非继承来实现运行时多态。让我们来看看 trait 对象是如何工作的。
