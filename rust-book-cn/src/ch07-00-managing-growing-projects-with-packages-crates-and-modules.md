<!-- Old headings. Do not remove or links may break. -->

<a id="managing-growing-projects-with-packages-crates-and-modules"></a>

# 包、Crate 和模块

随着你编写的程序规模越来越大，组织代码将变得愈发重要。通过将相关功能分组，并将具有不同特性的代码分离开来，你可以清晰地知道到哪里去找实现某个特定功能的代码，以及到哪里去修改某个功能的行为。

到目前为止，我们编写的程序都在一个文件的一个模块中。随着项目的增长，你应该通过将代码拆分为多个模块、再拆分为多个文件来组织代码。一个包（package）可以包含多个二进制 crate，以及一个可选的库 crate。随着包的增长，你可以将其中的部分提取为独立的 crate，使其成为外部依赖。本章将涵盖所有这些技术。对于由一组相互关联、共同演进的包组成的超大型项目，Cargo 提供了工作空间（workspace）功能，我们将在第 14 章的["Cargo 工作空间"][workspaces]<!-- ignore -->中介绍。

我们还将讨论封装实现细节，这使你能够在更高层次上复用代码：一旦你实现了某个操作，其他代码就可以通过其公共接口来调用你的代码，而无需了解实现的内部工作原理。你编写代码的方式决定了哪些部分是公开的、可供其他代码使用，哪些部分是私有的实现细节、你保留随时修改的权利。这是另一种减少你需要记在脑中的细节数量的方法。

一个相关的概念是作用域（scope）：代码所处的嵌套上下文中有一组被定义为"在作用域内"的名称。在阅读、编写和编译代码时，程序员和编译器都需要知道某个特定位置的特定名称是指变量、函数、结构体、枚举、模块、常量还是其他条目，以及该条目的含义。你可以创建作用域，并改变哪些名称在作用域内或作用域外。同一个作用域中不能有两个同名的条目；不过有一些工具可以用来解决名称冲突。

Rust 提供了一系列功能，让你能够管理代码的组织结构，包括哪些细节是公开的、哪些细节是私有的，以及程序中每个作用域里有哪些名称。这些功能有时被统称为**模块系统**（_module system_），包括：

* **包（Package）**：Cargo 的一个功能，让你构建、测试和分享 crate
* **Crate**：一个由模块组成的树形结构，可以生成库或可执行文件
* **模块（Module）和 use**：让你控制路径的组织结构、作用域和私有性
* **路径（Path）**：一种命名条目的方式，例如结构体、函数或模块

在本章中，我们将涵盖所有这些功能，讨论它们之间如何交互，并解释如何使用它们来管理作用域。读完本章后，你应该对模块系统有扎实的理解，并能够熟练地使用作用域！

[workspaces]: ch14-03-cargo-workspaces.html
